import copy
import json
import re
import traceback
from typing import Dict, Iterator, List, Optional, Union, Tuple

import json5

from qwen_agent import Agent
from qwen_agent.llm.base import BaseChatModel
from qwen_agent.llm.schema import CONTENT, DEFAULT_SYSTEM_MESSAGE, Message, FUNCTION, Session, Turn, SKILL_REC, \
    FunctionCall
from qwen_agent.agents import SkillRecognizer
from qwen_agent.tools import BaseTool
from qwen_agent.settings import MAX_LLM_CALL_PER_RUN

DEFAULT_NAME = 'Skill Recognizer'
DEFAULT_DESC = '可以根据问题，识别出用户输入信息中需要使用哪种外部工具'


class WealthyConsultant(Agent):
    """This is an agent for doc QA."""

    def __init__(self,
                 function_list: Optional[List[Union[str, Dict, BaseTool]]] = None,
                 llm: Optional[Union[Dict, BaseChatModel]] = None,
                 system_message: Optional[str] = DEFAULT_SYSTEM_MESSAGE,
                 name: Optional[str] = DEFAULT_NAME,
                 description: Optional[str] = DEFAULT_DESC):
        super().__init__(function_list=function_list,
                         llm=llm,
                         system_message=system_message,
                         name=name,
                         description=description)
        self.skill_rec = SkillRecognizer(llm=self.llm)
        self.session = Session(turns=[])

    def _run(self, messages: List[Message], lang: str = 'zh', **kwargs) -> Iterator[List[Message]]:
        if messages[-1].content[0].text.strip() == '':
            raise ValueError("请输入有关信息")
        # New Turn, add user message to session
        turn = Turn(user_input=messages[-1].content[0].text)

        # call skill recognizer
        skill_res = list(self.skill_rec.run(messages=messages, sessions=self.session, function_map=self.function_map,
                                            lang=lang))[-1][0]
        # for output in skill_res:
        #     if output:
        #         response = response + output

        turn.skill_rec = skill_res

        # detect and call tools

        use_tool, tool_name, tool_args, _ = self._detect_tool(skill_res)
        # if use_tool:
        #     tool_result = self._call_tool(tool_name, tool_args, messages=messages, **kwargs)
        # else:
        #     # todo: process no tool res
        #     pass

        # # add tools result to session
        # turn.tool_res = {tool_name: tool_result}

        # yield final result and add result to session assistant message

        turn.assistant_output = skill_res.content
        self.session.add_turn(turn)

        print(self.session)
        yield [skill_res]

    def _detect_tool(self, message: Message) -> Tuple[bool, str, str, str]:
        """A built-in tool call detection for func_call format message.

        Args:
            message: one message generated by LLM.

        Returns:
            Need to call tool or not, tool name, tool args, text replies.
        """
        func_name = None
        func_args = None
        # if isinstance(message, dict):
        #     if "function_call" in message:
        #         # todo: process multi function calls
        #         func = message["function_call"][0]
        #         message = Message(
        #             function_call=FunctionCall(name=func["name"], arguments=json.dumps(func["parameters"])),
        #             role="assistant", content="")
        content = message.content
        if "```" in content:
            pattern = r'```(?:JSON|json)\s*(.*?)```'
            content = re.findall(pattern, content, re.DOTALL)[0]
        func = json5.loads(content)["function_call"]
        if func:
            function = FunctionCall(name=func[0]["name"], arguments=json.dumps(func[0]["parameters"]))
        else:
            function = FunctionCall(name="", arguments="[]")

        if message.function_call:
            # func_call = function
            func_name = function.name
            func_args = function.arguments
        text = message.content
        if not text:
            text = ''

        return (func_name is not None), func_name, func_args, text
