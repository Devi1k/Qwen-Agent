import copy
import json
import re
import traceback
from typing import Dict, Iterator, List, Optional, Union, Tuple
import os
import json5

from qwen_agent import Agent
from qwen_agent.llm.base import BaseChatModel
from qwen_agent.llm.schema import CONTENT, DEFAULT_SYSTEM_MESSAGE, Message, FUNCTION, Session, Turn, SKILL_REC, \
    FunctionCall, ToolResponse
from qwen_agent.agents import SkillRecognizer
from .summarize import Summarizer

from qwen_agent.tools import BaseTool
from qwen_agent.settings import MAX_LLM_CALL_PER_RUN

DEFAULT_NAME = 'Skill Recognizer'
DEFAULT_DESC = '可以根据问题，识别出用户输入信息中需要使用哪种外部工具'


class WealthyConsultant(Agent):
    """This is an agent for doc QA."""

    def __init__(self,
                 function_list: Optional[List[Union[str, Dict, BaseTool]]] = None,
                 llm: Optional[Union[Dict, BaseChatModel]] = None,
                 system_message: Optional[str] = DEFAULT_SYSTEM_MESSAGE,
                 name: Optional[str] = DEFAULT_NAME,
                 description: Optional[str] = DEFAULT_DESC):
        super().__init__(function_list=function_list,
                         llm=llm,
                         system_message=system_message,
                         name=name,
                         description=description)
        self.skill_rec = SkillRecognizer(llm=self.llm)
        self.session = Session(turns=[])

        self.summarizer = Summarizer(llm=self.llm)
        # self.summarizer = None

    def _run(self, messages: List[Message], lang: str = 'zh', **kwargs) -> Iterator[List[Message]]:
        if messages[-1].content[0].text.strip() == '':
            raise ValueError("请输入有关信息")
        # New Turn, add user message to session
        turn = Turn(user_input=messages[-1].content[0].text)

        # call skill recognizer
        skill_res = list(self.skill_rec.run(messages=messages, sessions=self.session, function_map=self.function_map,
                                            lang=lang))[-1][0]
        # for output in skill_res:
        #     if output:
        #         response = response + output

        turn.skill_rec = skill_res

        # detect and call tools

        use_tool, tool_name, tool_args, _ = self._detect_tool(skill_res)
        if use_tool:
            tool_response = self._call_tool(tool_name, tool_args, messages=messages, llm=self.llm,
                                            session=self.session,
                                            **kwargs)
        else:
            tool_response = ToolResponse("no tools used")

        # # add tools result to session
        turn.tool_res = tool_response
        # yield final result and add result to session assistant message
        if tool_response.reply != "":
            turn.assistant_output = tool_response.reply
            tmp_res = ""
            for t in tool_response.reply:
                tmp_res += t
                yield [Message(role="assistant", content=tmp_res)]
        else:
            # todo: call llm for summarize
            response = []
            for rsp in self.summarizer.run(messages=messages, sessions=self.session, turn=turn):
                response += rsp
                yield rsp
            turn.assistant_output = response[-1].content

        self.session.add_turn(turn)

    def _detect_tool(self, message: Message) -> Tuple[bool, str, str, str]:
        """A built-in tool call detection for func_call format message.

        Args:
            message: one message generated by LLM.

        Returns:
            Need to call tool or not, tool name, tool args, text replies.
        """
        func_name = None
        func_args = None
        # if isinstance(message, dict):
        #     if "function_call" in message:
        #         # todo: process multi function calls
        #         func = message["function_call"][0]
        #         message = Message(
        #             function_call=FunctionCall(name=func["name"], arguments=json.dumps(func["parameters"])),
        #             role="assistant", content="")
        content = message.content
        if "```" in content:
            pattern = r'```(?:JSON|json)\s*(.*?)```'
            content = re.findall(pattern, content, re.DOTALL)[0]
        func = json5.loads(content)["function_call"]
        if func:
            func_name, func_args = func[0]["name"], func[0]["parameters"]
        else:
            func_name, func_args = "", []
        # if message.function_call:
        #     # func_call = function
        #     func_name = function.name
        #     func_args = function.arguments
        text = message.content
        if not text:
            text = ''

        return (func_name is not None), func_name, func_args, text
